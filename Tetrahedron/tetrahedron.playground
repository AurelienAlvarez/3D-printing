/*: Tetrahedron. Computes a STL file.

# Le tétraèdre

Dans R^4, on note P, Q, R, S les quatre sommets du simplexe standard dont les coordonnées sont :
 - P = (1, 0, 0, 0)
 - Q = (0, 1, 0, 0)
 - R = (0, 0, 1, 0)
 - S = (0, 0, 0, 1)
 
Ces quatre points appartiennent à l'hyperplan affine d'équation x1 + x2 + x3 + x4 = 1. Notons P0 le point de coordonnées 1/4 (1, 1, 1, 1) que nous prendrons comme origine de l'hyperplan affine précédent.
 
Un vecteur normal unitaire à cet hyperplan est n = 1/2 (1, 1, 1, 1). Une base orthnormale de l'hyperplan est donnée par les trois vecteurs :
 - u1 = 1/sqrt(2) (1, -1, 0, 0)
 - u2 = 1/2 (1, 1, -1, -1)
 - u3 = 1/sqrt(2) (0, 0, 1, -1)
 
Le calcul du déterminant (u1, u2, u3, n) donne 1, ce qui assure cette base d'être orthonormée directe.

Des calculs élémentaires permettent de calculer les coordonnées des points P, Q, R, S dans le repère orthonormal P0 + (u1, u2, u3). On trouve :
 - P = (1/sqrt(2), 1/2, 0)
 - Q = (-1/sqrt(2), 1/2, 0)
 - R = (0, -1/2, 1/sqrt(2))
 - S = (0, -1/2, -1/sqrt(2))
 
Le centre de la face (PQR) est le point C = P + Q + R de coordonnées (0, 1/2, 1/sqrt(2)). On en déduit qu'un vecteur normal à cette face dirigé vers l'extérieur du tétraèdre est le vecteur SC = (0, 1, sqrt(2)). Le calcul du produit vectoriel de PQ par PR donne précisément le vecteur SC, ce qui assure que la face (PQR) est bien orientée. On en déduit ainsi la liste des quatre faces orientées :
 - (PQR)
 - (PRS)
 - (PSQ)
 - (QSR)
 
Enfin, notons que dans le tétraèdre, deux sommets distincts sont reliés par une arête.
*/


//: # Let's go!

import Cocoa

//: ## Linear structure

struct Vect {
    let x, y, z: Double
    
    init(x: Double, y: Double, z: Double) {
        self.x = x
        self.y = y
        self.z = z
    }
    
    static func + (v1: Vect, v2: Vect) -> Vect {
        return Vect(x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z)
    }
    static func - (v1: Vect, v2: Vect) -> Vect {
        return Vect(x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z)
    }
}

func wedge_product(v1: Vect, v2: Vect) -> Vect {
    let nx = v1.y * v2.z - v1.z * v2.y
    let ny = v2.x * v1.z - v2.z * v1.x
    let nz = v1.x * v2.y - v1.y * v2.x
    return Vect(x: nx, y: ny, z: nz)
}

func rotation_x(cos_theta: Double, sin_theta: Double, v: Vect) -> Vect {
    return Vect(x: v.x, y: cos_theta * v.y - sin_theta * v.z, z: sin_theta * v.y + cos_theta * v.z)
}

//: ## Affine structure

struct Vertex {
    var x, y, z: Double
    
    init(x: Double, y: Double, z: Double) {
        self.x = x
        self.y = y
        self.z = z
    }
    
    func translate(v: Vect) -> Vertex {
        return Vertex(x: x + v.x, y: y + v.y, z: z + v.z)
    }
}

//: Computes vector AB (from point A to B)
func points_to_vect(A: Vertex, B: Vertex) -> Vect {
    return Vect(x: B.x - A.x, y: B.y - A.y, z: B.z - A.z)
}

//: ## Polyhedral structure
struct Edge {
    let origin, terminal: Vertex
    
    init(origin: Vertex, terminal: Vertex) {
        self.origin = origin
        self.terminal = terminal
    }
    
    func opp() -> Edge {
        return Edge(origin: terminal, terminal: origin)
    }
    
    func toVect() -> Vect {
        return Vect(x: terminal.x - origin.x, y: terminal.y - origin.y, z: terminal.z - origin.z)
    }
}

struct Face {
    let vertex_1, vertex_2, vertex_3: Vertex

    init(vertex_1: Vertex, vertex_2: Vertex, vertex_3: Vertex) {
        self.vertex_1 = vertex_1
        self.vertex_2 = vertex_2
        self.vertex_3 = vertex_3
    }
}

//: Computes unitary normal to a face
func normal_face(face : Face) -> Vect {
    let v1: Vect = points_to_vect(A: face.vertex_1, B: face.vertex_2)
    let v2: Vect = points_to_vect(A: face.vertex_1, B: face.vertex_3)
    let n: Vect = wedge_product(v1: v1, v2: v2)
    let norm = sqrt(n.x * n.x + n.y * n.y + n.z * n.z)
    return Vect(x: n.x/norm, y: n.y/norm, z: n.z/norm)
}

//: ## Tetrahedron

struct Tetrahedron {
    let P, Q, R, S: Vertex
    
    init(P: Vertex, Q: Vertex, R: Vertex, S: Vertex) {
        self.P = P
        self.Q = Q
        self.R = R
        self.S = S
    }
    
    var PQ: Edge {
        get { return Edge(origin: P, terminal: Q) }
    }
    var PR: Edge {
        get { return Edge(origin: P, terminal: R) }
    }
    var PS: Edge {
        get { return Edge(origin: P, terminal: S) }
    }
    var QR: Edge {
        get { return Edge(origin: Q, terminal: R) }
    }
    var RS: Edge {
        get { return Edge(origin: R, terminal: S) }
    }
    var SQ: Edge {
        get { return Edge(origin: S, terminal: Q) }
    }

    var PQR: Face {
        get { return Face(vertex_1: P, vertex_2: Q, vertex_3: R) }
    }
    var PRS: Face {
        get { return Face(vertex_1: P, vertex_2: R, vertex_3: S) }
    }
    var PSQ: Face {
        get { return Face(vertex_1: P, vertex_2: S, vertex_3: Q) }
    }
    var QSR: Face {
        get { return Face(vertex_1: Q, vertex_2: S, vertex_3: R) }
    }

    var vertices: [Vertex] {
        get { return [P, Q, R, S] }
    }
    var edges: [Edge] {
        get { return [PQ, PR, PS, QR, RS, SQ] }
    }
    var faces: [Face] {
        get { return [PQR, PRS, PSQ, QSR] }
    }
    
    func rotation(cos_theta: Double, sin_theta: Double) -> Tetrahedron {
        let S_rot_SP = S.translate(v: rotation_x(cos_theta: cos_theta, sin_theta: sin_theta, v: PS.opp().toVect()))
        let S_rot_SQ = S.translate(v: rotation_x(cos_theta: cos_theta, sin_theta: sin_theta, v: SQ.toVect()))
        let S_rot_SR = S.translate(v: rotation_x(cos_theta: cos_theta, sin_theta: sin_theta, v: RS.opp().toVect()))
        return Tetrahedron(P: S_rot_SP, Q: S_rot_SQ, R: S_rot_SR, S: S)
    }
}

//: ### Tetrahedron definition and rotation in 3-space

let P = Vertex(x: sqrt(2)/2.0, y: 0.5, z: 0.0)
let Q = Vertex(x: -sqrt(2)/2.0, y: 0.5, z: 0.0)
let R = Vertex(x: 0.0, y: -0.5, z: sqrt(2)/2.0)
let S = Vertex(x: 0.0, y: -0.5, z: -sqrt(2)/2.0)

let tetrahedron_init = Tetrahedron(P: P, Q: Q, R: R, S: S)

let cos_theta: Double = sqrt(2.0/3.0)
let sin_theta: Double = -sqrt(1.0/3.0)

let tetrahedron = tetrahedron_init.rotation(cos_theta: cos_theta, sin_theta: sin_theta)

//: ## Triangulation (STL format)

let scale: Double = 100.0

print("solid tetrahedron")

for face in tetrahedron.faces {
    let normal =  normal_face(face: face)
    print("facet normal \(Float32(normal.x)) \(Float32(normal.y)) \(Float32(normal.z))")
    print("  outer loop")
    let face_vertices: [Vertex] = [face.vertex_1, face.vertex_2, face.vertex_3]
    for vertex in face_vertices {
        print("    vertex \(Float32(scale * vertex.x)) \(Float32(scale * vertex.y)) \(Float32(scale * vertex.z))")
    }
    print("  endloop")
    print("endfacet")
}

print("endsolid")
